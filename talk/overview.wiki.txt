<[autotemplate]
beamertemplatenavigationsymbolsempty={}
title={ALPSCore tutorial}
author={Alexander Gaenko}
usetheme={Frankfurt}
usecolortheme={whale}
lstloadlanguages={sh,C++}
lstset={escapeinside={\#(}{)},style=basic,basicstyle=\small,basewidth=0.5em,emphstyle={\color{blue}}}
definecolor={babyblue}{rgb}{0.54, 0.81, 0.94}
definecolor={ballblue}{rgb}{0.13, 0.67, 0.8}
definecolor={albatrosred}{HTML}{CA4436}
newcommand={\code}[1]{\texttt{#1}}
[autotemplate]>

== Overview ==

==== Overview ====

This tutorial contains:
* General overview of ALPSCore.
* Hands-on exercises:
** Installation of ALPSCore.
** Use of ALPSCore to gradually build\\a feature-rich simulation code.
* The hand-out materials contain (not necessarily in this order):\\[-0.3\baselineskip]
*# These slides.
*# Hands-on exercises.
*# Useful links.
*# Diff files highlighting changes as we put in new features.
*# Diff files that define exercises solutions. 
*# Source code of the tutorial programs.

The solutions to the exercises are available online: \url{https://git.io/alpstut2_solutions}

== Introduction == 

====  ====

<[center]
'''_blue_INTRODUCTION_'''
[center]>

==== What it is about ====
ALPSCore originated from Algorithms and Libraries for Physics Simulations (ALPS) \url{http://alps.comp-phys.org}\\
'''The grand idea''': 
Make the _blue_library code_ 
from ALPS available with 
_blue_shorter development cycle_ and
_blue_decent documentation_.

* What is the _ballblue_library code_?
** That will most probably useful for many applications.
** However, ALPSCore is oriented towards Monte Carlo.

* What is the _ballblue_development cycle_? 
** Introducing features (by request?)
** Testing the features
** Fixing bugs
** Documenting

* What is _ballblue_decent documentation_?
** User's documentations
** Tutorials (like this one!)
** Developer's Doxygen-generated reference.

==== Web sites ====

Contributors:
* Emanuel Gull's group, University of Michigan (USA);
* Lukas Gamper, ETH Zurich (Switzerland);
* ... and many other ALPS contributors.

* Source code: \url{https://github.com/ALPSCore/ALPSCore}
* Documentation \& tutorials:  \url{http://alpscore.org}
* CloudBees for Continuous Delivery. 

<<<alpscore_sites.pdf,height=0.3\textheight>>>


==== Why to use ALPSCore? ====

Think of a typical MC simulation to-do:

# _ballblue_Read the simulation parameters._
# _albatrosred_Decide the step in the phase space._
# _albatrosred_Calculate ("measure") the values of interest._
# _ballblue_Collect statistics properly, taking into account autocorrelation._
# _ballblue_Compute derived values with proper error propagation._
# _ballblue_Save intermediate results regularly._
# _ballblue_Set the step or time limit on the simulation._
# _ballblue_Parallelize the whole thing._

Except the _albatrosred_highlighted items_, everything else is "boilerplate".\\
Sometimes non-trivial one!

_blue_Use ALPSCore to minimize boilerplate programming and concentrate on relevant science._

==== Overview ====
<<<alpscore_classes.pdf,height=0.8\textheight,width=\textwidth,keepaspectratio>>>


== Installing ALPSCore  == 

==== ====
<[center]
'''_blue_INSTALLING ALPSCore_'''
[center]>

==== Tutorial prerequisites ====
_blue_What do you need to_ ''_blue_know?_''
# Basic Unix command-line operations
# Basic C++
# Optional: git
# Optional: installing packages for your OS
# Optional: CMake

_blue_What do you need to_ ''_blue_have?_''
# Git
# CMake
# C++ compiler
# HDF5 package
# Boost package
# MPI package


==== Obtainig ALPSCore ====
'''How to get ALPSCore?'''
* Downloading release: \\ \hspace{-1em}\url{https://github.com/ALPSCore/ALPSCore/releases}
* Getting from GitHub: \\ \hspace{-1em}@git clone https://github.com/ALPSCore/ALPSCore.git@
* Installing an ALPSCore package:
** Via @macports@ or @homebrew@ on  MacOS~X.
** Via @portage@ on Gentoo Linux.
** Debian or RedHat binary packages may be created\\ if demand arises.
-- 2\baselineskip --

==== Building and compilation ====

There are (of course\!) prerequisites.

* _blue_Tools_:
** C++03  (not @C++1x@ --- by policy). \\Tested with GCC 4.2+, Intel 10.0+, Clang 3.2+
** CMake 2.8.12+

* _blue_Libraries_:
** HDF5 1.8+
** Boost 1.54.0+
** MPI (technically, optional)
** GoogleTest (included!)

==== Building and compilation ====

* ALPSCore will try to find Boost, HDF5 and MPI. 
* Usually, if you can run @mpicc@, ALPSCore will also find MPI.
* Building using CMake command line:

<[code][language=sh,emph={DBOOST_ROOT,DHDF5_ROOT,DCMAKE_INSTALL_PREFIX},emphstyle=\color{blue},basicstyle=\ttfamily]
$ cmake -DBOOST_ROOT=/path/to/boost \
        -DHDF5_ROOT=/path/to/hdf5 \
        -DCMAKE_INSTALL_PREFIX=/usr/local/ALPSCore \
        /path/to/alpscore/sources
$ make
$ make install
[code]>

* There are some other CMake variables, less frequently used

==== Exercise 1 ====[t]
_blue_Exercise 1:_ Download and install this tutorial

Open a terminal. Then, enter the following commands.

<[code][language=sh,emph={ls,cd,mkdir,git},basicstyle=\ttfamily]
$ cd ~
$ mkdir alpstut
$ cd alpstut
$ git clone https://github.com/ALPSCore/Tutorial2.git
$ cd Tutorial2
$ tutorial=$PWD
$ ls -l
[code]> 
You should see a list of files and no error messages.

==== Exercise 2 ====[t]
_blue_Exercise 2:_ Download/install prerequisites
<[center]
Ubuntu Linux
<[code][language=sh,basicstyle=\ttfamily\small,emph={sudo,apt,get}]
$ sudo apt-get install cmake
$ sudo apt-get install libhdf5-dev
$ sudo apt-get install libboost-all-dev
$ sudo apt-get install mpi-default-dev
[code]>
[center]>
<[center]
Mac OS X, port system
[center]>
<[code][language=sh,basicstyle=\ttfamily\small,emph={port}]
$ port install alpscore
[code]>
This will install the latest ALPSCore release (we don't need it!)
and prerequisites.

<[nowiki]
% <[center]
% Mac OS X, port system !FIXME!
% [center]>
% <[code][language=sh,basicstyle=\ttfamily\small,emph={sudo,port}]
% $ sudo port install gcc???
% $ sudo port install cmake
% $ sudo port install libhdf5-dev???
% $ sudo port install libboost-all-dev???
% $ sudo port install mpi-default-dev???
% [code]>
[nowiki]>

==== Exercise 2 ====[t]
_blue_Exercise 2 (cont):_ Download/install prerequisites
\ \\[3\baselineskip]
Test that you indeed have them:
<[code][language=sh,basicstyle=\ttfamily\small,emph={cmake,gcc,h5cc,mpicxx}]
$ cmake --version
$ #(\textcolor{blue}{g++}) --version
$ h5cc --version
$ mpicxx --version
[code]>


==== Exercise 3 ====
_blue_Exercise 3:_ Download and install ALPSCore.
<[code][language=sh,basicstyle=\ttfamily\small,emph={git,export,cmake,make,cd,mkdir}]
$ git https://github.com/ALPSCore/ALPSCore
$ cd ALPSCore
$ mkdir build
$ cd build
$ export ALPSCore_DIR=$PWD/install
$ cmake -DCMAKE_INSTALL_PREFIX=$ALPSCore_DIR ..
$ make
$ make test
$ make install
[code]>
*[1:] get ALPSCore from GitHub repository.
*[2--4:] create a directory for the build
*[5:] denote where it will be installed
*[6:] generate the build
*[7--9:] do the build, run the tests, and install


== Using ALPSCore == 

==== ====
<[center]
'''_blue_USING ALPSCore_'''
[center]>


==== Using ALPSCore in your program ====

Note: @ALPSCore\_DIR@ is pointing to the installation directory.

* How @CMakeLists.txt@ should look to use @ALPSCore@:\\ \url{https://git.io/alpstut2_s1_cmake}
* Catch: compilers!
* !In-source builds are messy!

<[code][language=sh,emph={ALPSCore_DIR},emphstyle=\color{blue},basicstyle=\ttfamily]
$ export CXX=$(which #(\textit{needed\_cpp}))
$ export CC=$(which #(\textit{needed\_cc}))
$ mkdir 000build 
$ cd 000build 
$ cmake ..
[code]>

==== Using ALPSCore in your program ====[t]
_blue_A few tips and possible catches:_

* Most of times, it is enough to remake after any file changes: \\ @\$ make@
* To speed up on 4 cores:\\@\$ make -j4@
* Catch: if CMake files change: \\ @\$ cmake .@ \\ in the build directory
* Catch: if compilers change: \\ @\$ rm -rf CMake*@
* Catch: after accidental in-source build,\\ remove the generated files.
* Catch: if @ALSPCore@ itself is updated, regenerate: \\ @\$ cmake .@ \\ in your build directory

==== Exercise 4 ====
_blue_Exercise 4:_ Build and run a dummy program\\ that uses ALPSCore and does nothing.

The code is at \texttt{\color{ballblue}\$tutorial/step1\_trivial}.

CMake file online: \url{https://git.io/alpstut2_s1_cmake}

Source file online: \url{https://git.io/alpstut2_s1_main}

+<2>{
<[code][language=sh,emph={cd,mkdir},basicstyle=\ttfamily\small]
$ cd $tutorial/step1_trivial
$ mkdir 000build
$ cd 000build
$ cmake ..
$ make
$ ./alpsdemo
[code]>
}


==== Parameters ====

* @alps::params@ class is responsible for parameter parsing.
* @boost::program\_options@ is the engine.
* See Doxygen documentation (link from \url{http://alpscore.org/}) for detailed info.

Features:

* One can use input file, override with command line.
* Input file may contain sections: @[title]@
* Parameters must be defined to make it known.
* Unknown parameters in silently ignored.
* Auto-generated help message.
* Accessing an undefined parameter throws an exception.
* You can assign to parameters, which makes them defined.
* Potential information loss ==> exception.

==== Exercise 5 ====
_blue_Exercise 5:_ Build and run a program\\ that uses parameters.

The code is at \texttt{\color{ballblue}\$tutorial/step2\_params}.

Online: \url{https://git.io/alpstut2_s2}

* Play with the different values of parameters. 
* Try to override them from the command line.
* Change the program to make ``\code{--loud}" parameter an integer, \\ with @0@ meaning ``be quiet''.
+<2>{
<[code][language=sh,emph={cd,mkdir},basicstyle=\ttfamily\tiny]
$ cd $tutorial/step2_params
$ mkdir 000build
$ cd 000build
$ cmake ..
$ make
$ ./alpsdemo
$ ./alpsdemo --help
$ ./alpsdemo ../params.ini
$ ./alpsdemo ../params.ini --count=3
....
[code]>
}

==== Simple simulation class (doing nothing) ====

* Simulation that just says ``I am running.''
* Derived from \code{\color{ballblue}alps::mc\_base} class.
* Must define virtual methods:
** @_blue_void measure()_@
** @_blue_void update()_@
** \code{\color{blue}double fraction\_completed()}
* Should define static method:
** \code{\color{blue}static\\parameters\_type\&~define\_parameters(parameters\_type\&)}
* Passes to the base class constructor:
** parameters object
** a PRNG seed offset (will be needed for parallel simulations)

==== Exercise 6 ====
_blue_Exercise 6:_ Build and run a trivial MC program.

The code is at \texttt{\color{ballblue}\$tutorial/step3\_trivial\_mc}.

Online: \url{https://git.io/alpstut2_s3}

Note: the simulation code is split into 2 files.

* Build and run.
* Run with small counts.
* Run with large count and small timelimit; time the execution:\\@\$ time -p ''your\_command''@
+<2>{
<[code][language=sh,emph={time}]
$ time -p ./alpsdemo --count=10000000 --timelimit=1
[code]>}
* Set large time limit and interrupt the program (via @Ctrl-C@).
* Change @fraction\_completed()@ so that @--count=0@ would mean ``till timeout''.
* Change the name of the @update()@ method\\and see it does not compile any more.

==== Compute $\pi$ by Markov chain MC ====
The problem:
<[columns]
[[[0.85\textwidth]]]
* Integral of objective function over an area.
* Trivial Metropolis step to stay inside the area. 
* Area: unit square; any step outside is rejected.
* Objective function: \\ 1 if inside an inscribed circle, 0 otherwise.
* Expected result: $\pi$ (if multiplied by 4).
[[[0.30\textwidth]]]
<<<square-circle.pdf,width=0.7\textwidth>>>
[columns]>
\ \\[0.3\baselineskip]
We need to use:
* '''_blue_Accumulators_''': named observable to gather statistics
* '''_blue_Results_''': named as accumulators, allow arithmetic operations (with error propagation!)
* Accumulators \& Results can hold a vector \\ (e.g., for vector-valued or parametrized objective function)

==== Types of accumulators ====
'''Types of accumulators''':
# Mean only (cheapest, least useful): @_blue_MeanAccumulator_<double>@
# No binning  (cheap, no autocorrelation info): @_blue_NoBinningAccumulator_<double>@
# \mbox{Full binning (most expensive, autocorrelation, error propagation):\hspace{-2em}}\\ @_blue_FullBinningAccumulator_<double>@
# Log binning (less memory demanding, no error propagation): @_blue_LogBinningAccumulator_<double>@

_albatrosred_If a method is not available for the given accumulator type, it throws!_

==== Exercise 7 ====
_blue_Exercise 7:_ Compute $\pi$ by Markov chain MC.

The code is at \texttt{\color{ballblue}\$tutorial/step4\_pi}.

Online: \url{https://git.io/alpstut2_s4}

* Build and run the program.
* Run with various time limits.
* Run with different step sizes, compare autocorrelation lengths.
* \mbox{Replace @FullBinningAccumulator@ to @NoBinningAccumulator@\hspace{-2em}}
* Run with very low or high @--step@ \\and see the underestimated error~bars.

==== Checkpointing the simulation ====

* Checkpoint: save intermediate results, load to resume 
* ALPSCore utilizes _blue_HDF5 format_
** Cross-platform
** Hierarchical structure: Groups ($\sim$directories), Data ($\sim$files)
* ALPSCore can save/load:
** Basic types (@int@, @double@ ''etc.'')
** Vectors of basic types and of vectors of basic types ''etc.''
** Accumulators and parameters
** Any user-defined class 
*** Via @save()@/@load()@ class members
*** Via traits (harder to do --- more complex code)
* Parameters can be constructed from HDF5 file too
** Should not try to define them again in this case! \\ Use @par.is\_restored()@.

==== Exercise 8 ====
_blue_Exercise 8:_ Running and resuming.

The code is in \texttt{\color{ballblue}\$tutorial/step5\_pi\_checkpoint}.

Online: \url{https://git.io/alpstut2_s5}

* Build and run the code. There is an error: find and fix it!
* Build, run the corrected code (note more options available!).
<[code][language=sh,basicstyle=\tiny\ttfamily]
$ ./alpsdemo --help
$ # Run for 5 sec
$ ./alpsdemo --step 1 --timelimit 5
[code]>
-- -\baselineskip --
* Note new files appear:
** ``@_blue_*.out_@'' file contains simulation results
** ``@_blue_*.clone.h5_@'' file contains checkpoint
* Restore the checkpoint:
<[code][language=sh,basicstyle=\tiny\ttfamily]
$ # Run for 10 more sec:
$ ./alpsdemo alpsdemo.clone.h5 --timelimit 10 
[code]>
-- -\baselineskip --
* Note:
** compulsory @_blue_--step_@ is read from the checkpoint
** parameters can be overridden (like @_blue_--timelimit_@)

==== How to use MPI? ====[t]

* Not many changes compared to the sequential version.
*# Use @alps::mcmpiadapter<@''SequentialSimulationClass''@>@\\ as your simulation class.
*# Initialize MPI environment
*# Make sure that the parallel processes \\ do not conflict for input/output
*# Use special constructor for parameters
* Note that the completion is checked only at certain intervals (1 sec minimum)
* Look at the code changes in your handouts.

<[nowiki]
% See the next slides for code changes!
% -- 3\baselineskip --
% ==== MPI: Header files ====
% 
% <[code][style=basic,language=C++,basicstyle=\small\ttfamily,basewidth=0.4em]
% #include <alps/mc/stop_callback.hpp>
% 
% [<2>#include <alps/mc/mpiadapter.hpp>]
% 
% class MySimulation : public alps::mcbase {
% // ... rest of your class ...
% };
% 
% [<2>typedef alps::mcmpiadapter<MySimulation> MyMpiSimulation;]
% // ... rest of your program ...
% [code]>
% 
% ==== MPI: main() ====
% 
% <[code][language=C++,basicstyle=\small\ttfamily,basewidth=0.4em]
%     alps::params p(argc, (const char**)argv);
% [<1>    MySimulation::define_parameters(p)][<2>    MyMpiSimulation::define_parameters(p)]
%             .description("Dummy Monte Carlo program")
% // etc...
% [<2>    // init MPI, obtain communicator]
% [<2>    alps::mpi::environment mpi_env(argc, argv);]
% [<2>    alps::mpi::communicator comm;]
% [<2>    // Parse the parameters on master...]
% [<2>    alps::params p;]
% [<2>    if (comm.rank()==0) { // on master process...]
% [<2>        alps::params p_master(argc, (const char**)argv);]
% [<2>        p=p_master;]
% [<2>    }]
% [<2>    broadcast(comm, p, 0); // ...broadcast parameters to all.]
% //....         
% [code]> 
[nowiki]>

==== Exercise 9 ====[t]

_blue_Exercise 9:_ Parallel runs.
--\baselineskip--
The code is in \texttt{\color{ballblue}\$tutorial/step6\_pi\_mpi}.

Online: \url{https://git.io/alpstut2_s6}

* Build the MPI-parallelized program.
* Do timed runs with different number of processes. 
* Observe checkpoint names.
* Try to restore from checkpoints, see how statistics builds up.

==== "Real-world" application: 2D Ising simulation ====[t]

* The same principle as any other MC simulation:
** Constructor: generated random spin population.
** Update step: try to flip a random spin; compute energy change.
** Measurements: energy, magnetization, magnetization squared.
* Performs arithmetics on results.
* For the sake of simplicity and clarity,\\a few optimization opportunities missed.
* The program uses a user-defined datatype,\\ therefore needs loading/saving for it.

==== Exercise 10 ====[t]

_blue_Exercise 10:_ Parallelize the 2D Ising code.

--\baselineskip--

The code is in \texttt{\color{ballblue}\$tutorial/step7\_ising}.

Online: \url{https://git.io/alpstut2_s7}

--\baselineskip--

Steps: 
# Initialize MPI environment.
# Use @alps::mcmpiadapter@ template.
# Use the parallel parameter constructor.
# Make sure each rank has its own checkpoint file.
# Make sure only the master process outputs the results.

<[nowiki]
% UNUSED
%* At this point, it is a good idea to indicate a debug or a release build:
%
%<[code][language=sh,emph={CMAKE_BUILD_TYPE},emphstyle=\color{blue},basicstyle=\ttfamily]
%$ cmake -DCMAKE_BUILD_TYPE=Debug ..
% # or:
%$ cmake -DCMAKE_BUILD_TYPE=Release ..
%[code]>
%
%* @Make@ command options:
%<[code][language=sh,basicstyle=\ttfamily]
%$ make VERBOSE=1 # runs make printing all commands
%$ make -j2 # run 2 Make processes, to compile faster
%$ nice make -j4 # 4 low-priority processes
%[code]>
%
%
% ==== For the next time ====
% * Use of vector accumulators to do something more complex, and accumulator operations
% * Assigning to parameters, from parameters
% * Proper installation
% ** ``install`` target
% ** Automatic setting of RPATH
[nowiki]>
